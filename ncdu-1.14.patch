diff -Naru ncdu-1.14/src/dir_import.c ncdu-1.14.new/src/dir_import.c
--- ncdu-1.14/src/dir_import.c	2019-02-04 23:49:57.000000000 +0800
+++ ncdu-1.14.new/src/dir_import.c	2019-07-08 19:20:54.061697254 +0800
@@ -286,6 +286,39 @@
   return 0;
 }
 
+static int rsint64(int64_t *val, int64_t max) {
+  int64_t v;
+  int haschar = 0;
+  int neg = 0;
+  *val = 0;
+  if(*ctx->buf == '-') {
+    neg = 1;
+    con(1);
+  }
+  while(1) {
+    C(!*ctx->buf && fill(1));
+    if(*ctx->buf == '0' && !haschar) {
+      con(1);
+      break;
+    }
+    if(*ctx->buf >= '0' && *ctx->buf <= '9') {
+      haschar = 1;
+      v = (*val)*10 + (*ctx->buf-'0');
+      E(v < *val, "Invalid (positive) integer");
+      *val = v;
+      con(1);
+      continue;
+    }
+    E(!haschar, "Invalid (positive) integer");
+    break;
+  }
+  E(*val > max, "Integer out of range");
+  if(neg) {
+    *val = -*val;
+  }
+  return 0;
+}
+
 
 /* Parse and consume a JSON number. The result is discarded.
  * TODO: Improve validation. */
@@ -437,10 +470,10 @@
       E(ctx->val[MAX_VAL-1] != 1, "Too large string value");
       strcpy(ctx->buf_name, ctx->val);
     } else if(strcmp(ctx->val, "asize") == 0) {      /* asize */
-      C(rint64(&iv, INT64_MAX));
+      C(rsint64(&iv, INT64_MAX));
       ctx->buf_dir->asize = iv;
     } else if(strcmp(ctx->val, "dsize") == 0) {      /* dsize */
-      C(rint64(&iv, INT64_MAX));
+      C(rsint64(&iv, INT64_MAX));
       ctx->buf_dir->size = iv;
     } else if(strcmp(ctx->val, "dev") == 0) {        /* dev */
       C(rint64(&iv, UINT64_MAX));
diff -Naru ncdu-1.14/src/util.c ncdu-1.14.new/src/util.c
--- ncdu-1.14/src/util.c	2019-02-04 23:49:57.000000000 +0800
+++ ncdu-1.14.new/src/util.c	2019-07-08 19:23:22.137221800 +0800
@@ -61,8 +61,8 @@
 }
 
 
-float formatsize(int64_t from, char **unit) {
-  float r = from;
+double formatsize(int64_t from, char **unit) {
+  double r = llabs(from);
   if (si) {
     if(r < 1000.0f)   { *unit = " B"; }
     else if(r < 1e6f) { *unit = "KB"; r/=1e3f; }
@@ -87,7 +87,7 @@
 
 void printsize(enum ui_coltype t, int64_t from) {
   char *unit;
-  float r = formatsize(from, &unit);
+  double r = formatsize(from, &unit);
   uic_set(t == UIC_HD ? UIC_NUM_HD : t == UIC_SEL ? UIC_NUM_SEL : UIC_NUM);
   printw("%5.1f", r);
   addchc(t, ' ');
diff -Naru ncdu-1.14/src/util.h ncdu-1.14.new/src/util.h
--- ncdu-1.14/src/util.h	2019-02-04 23:49:57.000000000 +0800
+++ ncdu-1.14.new/src/util.h	2019-07-08 19:24:06.321207756 +0800
@@ -129,7 +129,7 @@
 char *cropstr(const char *, int);
 
 /* Converts the given size in bytes into a float (0 <= f < 1000) and a unit string */
-float formatsize(int64_t, char **);
+double formatsize(int64_t, char **);
 
 /* print size in the form of xxx.x XB */
 void printsize(enum ui_coltype, int64_t);
@@ -160,7 +160,7 @@
  * behaviour, and (INT64_MAX - b >= a) didn't work for some reason. */
 #define adds64(a, b) ((a) > 0 && (b) > 0\
     ? ((uint64_t)(a) + (uint64_t)(b) > (uint64_t)INT64_MAX ? INT64_MAX : (a)+(b))\
-    : (a)+(b) < 0 ? 0 : (a)+(b))
+    : (a)+(b))
 
 /* Adds a value to the size, asize and items fields of *d and its parents */
 void addparentstats(struct dir *, int64_t, int64_t, uint64_t, int);
